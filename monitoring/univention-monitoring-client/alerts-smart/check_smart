#!/usr/bin/python3
# This script was created under contract for the US Government and is therefore Public Domain
#
# Changes and Modifications
# =========================
# Feb 3, 2009: Kurt Yoder - initial version of script
# Jul 22, 2022: Univention GmbH - migrate from Perl to Python and convert into writing Prometheus metrics
"""Check SMART status of ATA/SCSI disks, returning any usable metrics as perfdata."""

# FIXME: replace with /usr/share/prometheus-node-exporter/smartmon.sh ?!

import os
import re
import stat

from univention.config_registry import ucr
from univention.monitoring import Alert

SMART_COMMAND = '/usr/sbin/smartctl'


class SMART(Alert):

	def write_metrics(self):
		for device in ucr.get('monitoring/smart/devices/ata', '').split(','):
			if not self.skip_device(device):
				continue
			self.check_overall_health_status('ata', device)
			self.check_silent_health_status('ata', device)
			self.check_detailed_statistics('ata', device)

		for device in ucr.get('monitoring/smart/devices/scsi', '').split(','):
			if not self.skip_device(device):
				continue
			self.check_overall_health_status('scsi', device)
			self.check_silent_health_status('scsi', device)
			self.check_detailed_statistics('scsi', device)

	def skip_device(self, device):
		if not device:
			return True
		try:
			return not stat.S_ISBLK(os.stat(device).st_mode)
		except FileNotFoundError:
			return True

	def check_overall_health_status(self, interface, device):
		self.log.debug("CHECK 1: getting overall SMART health status")

		rc, output = self.exec_command([SMART_COMMAND, '-d', interface, '-H', device])

		# parse ata output, looking for "health status: passed"
		line_str = 'SMART overall-health self-assessment test result: '  # ATA SMART line
		ok_str = 'PASSED'  # ATA SMART OK string

		if interface == 'scsi':
			line_str = 'SMART Health Status: '  # SCSI SMART line
			ok_str = 'OK'  # SCSI SMART OK string

		health_status = -1  # not found
		for line in output.splitlines():
			match = re.search('%s(.+)' % re.escape(line_str), line)  # (line =~ /line_str(.+)/):
			if match:
				health_status = 1 if match.group(1) == ok_str else 0
				if health_status != 1:
					self.log.error("Health status: %s" % (match.group(1),))

		if health_status == -1:
			self.log.error('No health status line found')
		self.write_metric('univention_smart_overall_healthy', health_status, interface=interface, device=device)

	def check_silent_health_status(self, interface, device):
		self.log.debug("CHECK 2: getting silent SMART health check")

		rc, output = self.exec_command([SMART_COMMAND, '-d', interface, '-q', 'silent', '-A', device])

		rc_map = (
			('univention_smart_commandline_parse_failure', 0x01),  # Commandline parse failure
			('univention_smart_device_open_failure', 0x02),   # Device could not be opened
			('univention_smart_checksum_failure', 0x04),  # Checksum failure
			('univention_smart_disk_failing_failure', 0x08),  # Disk is failing
			('univention_smart_disk_in_prefail_failure', 0x10),  # Disk is in prefail
			('univention_smart_close_to_fail_failure', 0x20),  # Disk may be close to failure
			('univention_smart_logs_contains_errors_failure', 0x40),   # Error log contains errors
			('univention_smart_self_test_failure', 0x80),  # Self-test log contains errors
		)

		if rc:
			self.log.debug("non-zero exit code, generating error condition")
		else:
			self.log.debug("zero exit code, status OK")

		any_failure = False
		for metric_name, flag in rc_map.items():
			failure = (rc & flag)
			if failure:
				self.log.error('Failed: %s', metric_name)
				any_failure = True
			self.write_metric(metric_name, 1 if failure else 0, interface=interface, device=device)

		self.write_metric('univention_smart_unknown_returncode_failure', 1 if rc and any_failure else 0, interface=interface, device=device)  # critical

	def check_detailed_statistics(self, interface, device):
		self.log.debug("CHECK 3: getting detailed statistics")
		# information contains a few more potential trouble spots
		# plus, we can also use the information for perfdata/graphing

		rc, output = self.exec_command([SMART_COMMAND, '-d', interface, '-A', device])
		perfdata = []

		# separate metric-gathering and output analysis for ATA vs SCSI SMART output
		if interface == 'ata':
			for line in output.splitlines():
				# get lines that look like this:
				#    9 Power_On_Minutes        0x0032   241   241   000    Old_age   Always       -       113h+12m
				match = re.match(r'^\s*\d+\s(\S+)\s+(?:\S+\s+):6}(\S+)\s+(\d+)/', line)
				if not match:
					continue
				attribute_name, when_failed, raw_value = match.groups()
				if when_failed != '-':  # warning
					self.log.error("Attribute %s failed at %s" % (attribute_name, when_failed))
					return

				# some attributes produce questionable data; no need to graph them
				if 'Unknown_Attribute' in attribute_name or 'Power_On_Minutes' in attribute_name:
					continue

				perfdata.append('%s=%s' % (attribute_name, raw_value))

				# do some manual checks
				if attribute_name == 'Current_Pending_Sector' and raw_value:  # warning
					self.log.error("Sectors pending re-allocation")
					return
		else:
			current_temperature, max_temperature, current_start_stop, max_start_stop = [], [], [], []
			for line in output.splitlines():
				match = re.match(r"Current Drive Temperature:\s+(\d+)", line)
				if match:
					current_temperature = match.group(1)
				match = re.match(r"Drive Trip Temperature:\s+(\d+)", line)
				if match:
					max_temperature = match.group(1)
				match = re.match(r"Current start stop count:\s+(\d+)", line)
				if match:
					current_start_stop = match.group(1)
				match = re.match(r"Recommended maximum start stop count:\s+(\d+)", line)
				if match:
					max_start_stop = match.group(1)
				match = re.match(r"Elements in grown defect list:\s+(\d+)", line)
				if match:
					perfdata.append("defect_list=%s" % match.group(1))
				match = re.match(r"Blocks sent to initiator =\s+(\d+)", line)
				if match:
					perfdata.append("sent_blocks=%s" % match.group(1))

			if current_temperature:
				if max_temperature:
					perfdata.append('temperature=%s;;%s' % (current_temperature, max_temperature))
					if current_temperature > max_temperature:  # critical
						self.log.debug("Disk temperature is greater than max ($current_temperature > $max_temperature)")
						self.log.error('Disk temperature is higher than maximum')
						return
				else:
					perfdata.append('temperature=%s' % (current_temperature,))
			if current_start_stop:
				if max_start_stop:
					perfdata.append('start_stop=%s;%s' % (current_start_stop, max_start_stop))
					if current_start_stop > max_start_stop:  # warning
						self.log.debug("Disk start_stop is greater than max ($current_start_stop > $max_start_stop)")
						self.log.error('Disk start_stop is higher than maximum')
						return
				else:
					perfdata.append('start_stop=%s' % (current_start_stop,))


if __name__ == '__main__':
	SMART.main()
